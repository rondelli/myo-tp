\pdfoutput=1
\pdfpageattr{/Group << /S /Transparency /I true /CS /DeviceRGB>>}
\documentclass[11pt, a4paper, pdftex]{article}

\usepackage[british,spanish,es-minimal,es-sloppy]{babel}
\usepackage{verbatim}

\usepackage[hscale=0.75, vscale=0.70, vmarginratio=1:1,verbose]{geometry}

\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage[scaled=.80]{beramono}
%\usepackage{inconsolata}
%\usepackage{palatino}

\usepackage[safe,tone,extra]{tipa}
\usepackage{mflogo}

\usepackage{graphicx}
	\DeclareGraphicsRule{*}{mps}{*}{}

\usepackage{xcolor}
\usepackage{colortbl}

\usepackage{tikz} % no tiene opciones
	\usetikzlibrary{calc}
	\usetikzlibrary{arrows}
	\usetikzlibrary{backgrounds}
	\usetikzlibrary{decorations.pathmorphing}
	\usetikzlibrary{shapes.geometric}
	\tikzset{>=latex'}

\usepackage{pgfplots}
\usetikzlibrary{pgfplots.dateplot}

%\usepackage{gnuplot-lua-tikz} %para incluir gráficos de gnuplot usando el driver de TikZ

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{nicefrac}
\usepackage{mathrsfs}
\usepackage[Euler]{upgreek}
\usepackage[nointegrals]{wasysym}
\usepackage[version=3,arrows=pgf]{mhchem}
\usepackage[colorlinks,verbose]{hyperref}
	\hypersetup{bookmarksnumbered, bookmarksopen, bookmarksopenlevel=2}
	\hypersetup{pdfstartview=FitH}
	%\hypersetup{pdfpagelayout=TwoColumnRight}

\usepackage{booktabs}

\usepackage{listings}
	%\lstset{showspaces=true,showtabs=true,tab=\rightarrowfill} % DEBUGGING IT!
	\lstloadlanguages{Java,Python,[LaTeX]TeX}

	%\lstset{language=Java} %\lstset{language={[LaTeX]TeX}}
	\lstset{backgroundcolor=\color{blue!5}}
	\lstset{ % set number
		numbers=left,
		stepnumber=1,
		numberstyle=\tiny\color{black!50},
		numbersep=5pt
	}
	\lstset{
		%basewidth={0.65em,0.45em}, % ugly! see documentation for details!
		columns={[c]fullflexible}, % kind of acceptable ;)
		tabsize=5,
		showstringspaces=false,
		%basicstyle=\footnotesize\ttfamily,
		basicstyle=\ttfamily,
		keywordstyle=\bfseries\color{blue!50!black},
		%identifierstyle=\color{blue!75},
		stringstyle=\color{green!50!black},
		commentstyle=\slshape\color{black!50},
		%mathescape=true;
		%morecomment=[is]{/*}{*/}
	}
	%\renewcommand{\lstlistingname}{Fitting}
	%\lstset{basicstyle=\footnotesize\ttfamily}
	%\lstset{numbers=left, numberstyle=\tiny, numbersep=6pt}
	%\lstset{backgroundcolor=\color{blue!10}}
	%\lstset{captionpos=b}
	%\lstset{xleftmargin=16pt}

\usepackage{listingsutf8}

\usepackage{float}

\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{examp}{Ejemplo}[section]
\newenvironment{example}{\begin{examp} \upshape}{$\blacklozenge$ \end{examp}}

\newtheorem{obs}{Observación}[section]
\newenvironment{observation}{\begin{obs} \upshape}{$\blacktriangle$ \end{obs}}

\newtheorem{algor}{Algoritmo}[section]
\newenvironment{algorithm}{\begin{algor} \upshape}{$\blacksquare$ \end{algor}}

\newtheorem{law}{Ley}[section]

\newenvironment{ok}{\renewcommand{\labelitemi}{$\surd$}\begin{itemize}}{\end{itemize}}
\newenvironment{not:ok}{\renewcommand{\labelitemi}{$\times$}\begin{itemize}}{\end{itemize}}

\newcommand{\eg}{e.g.~}
\newcommand{\ie}{i.e.~}

\newcommand{\Emph}[1]{\textsc{#1}}
%\newcommand{\Vec}[1]{\mathbf{#1}}
\newcommand{\oldstyle}[1]{\ensuremath{\mathnormal{#1}}}

\newcommand{\differential}[1]{\:d#1}
\newcommand{\Power}{\mathscr{P}}

% Unit vectors
\newcommand{\iunitvec}{\hat{\imath}}
\newcommand{\junitvec}{\hat{\jmath}}
\newcommand{\kunitvec}{\hat{k}}
\newcommand{\unitvec}[1]{\hat{#1}}
\newcommand{\Unitvec}[1]{\widehat{#1}}

\renewcommand{\labelenumi}{(\roman{enumi})}

\newcounter{BloodyArabic}
\newcommand{\RomanNumber}[1]{\setcounter{BloodyArabic}{#1}\textsc{\roman{BloodyArabic}}}
\newcommand{\rungnuplot}[1]{\immediate\write18{cd ../plots; gnuplot #1.gp && mpost -tex=latex #1.mp}}
\newcommand{\mtopgf}[1]{\immediate\write18{m4 #1.m4 | dpic -g > #1.tex}}

\def\Lucifer{Hernán Rondelli}
\def\Xime{Ximena Ebertz}
\def\Lu{Lucía Soria}
\def\Mati{Matías Curcio}

\title{
	\huge MyO -- Trabajo Práctico\\
}
\author{
	\Mati \and \Xime \and \Lucifer \and \Lu
}
\date{\small $\text{2}^{\text{do}}$ Semestre 2024
}

\flushbottom
\begin{document}

\renewcommand{\contentsname}{Contenidos}
\renewcommand{\listfigurename}{Listado de Figuras}
\renewcommand{\listtablename}{Listado de Tablas}
\renewcommand{\tablename}{Tabla}

\newcommand{\minimize}{\texttt{Minimize}\quad\,\,}
\newcommand{\maximize}{\texttt{Maximize}\quad\,\,}
\newcommand{\subjto}{\texttt{Subject to}\quad}

\pdfbookmark{Título}{title}\maketitle

\tableofcontents

\newpage
\section{Primera parte}

\subsection{Introducción}

Se deben realizar backups de $n$ archivos de la empresa \emph{BigData}
en discos idénticos de capacidad $d$, sin dividir los archivos. Cada
archivo es menor que la capacidad de un disco. Se necesita saber cuál es
la cantidad mínima de discos necesarios para almacenar todos los
archivos, considerando la capacidad de cada disco y el tamaño de cada
archivo. 

\subsection{Modelo Lineal}

Para minimizar la cantidad de discos, utilizamos una variable binaria
$y_{j}$ que nos indica si se esta usando el disco $j$ o no, y otra
variable binaria $x_{ij}$ para identificar si cada archivo $i$ se guarda
en el disco $j$. Luego, establecimos tres restricciones: la primera se
asegura que cada archivo esté en un solo disco, la segunda, que los
tamaños de los archivos de cada disco no superen la capacidad del disco,
y la tercera define que no se usen discos vacíos---sería equivalente a
la implicación $x_{ij} \Rightarrow y_i$.

$F$: conjunto de nombres de cada archivo $i$, con $i = 1, \ldots, n$. \\

$s_{i}$: tamaño del archivo $i$ en MB, con $i = 1, \ldots, n$. \\

$n$: cantidad de archivos. \\

$m$: cantidad de discos disponibles, a lo sumo, un disco por archivo, $m = n$. \\

$D$: conjunto de $j$ discos de tamaño $d$, con $j = 1, \ldots, m$. \\

$d$: tamaño del disco en TB. \\ 

$x_{ij}$ binaria: $1$ indica si el archivo $i$ está en el disco $j$, $\forall i = \{1, \ldots, n\},\ \forall j = \{1, \ldots, m\}$, donde $x_{ij} \in \{0, 1\}$, $0$ en el caso de que no esté\\

$y_{j}$ binaria: $1$ indica que se está usando el disco $j$.

\begin{alignat*}{2}
	\minimize
	& \sum_{j = 1}^{m} y_{j}\\
	\subjto
	& \sum_{j = 1}^{m} x_{ij} = 1 \qquad \forall i \in \{1, \ldots, n\},\ \text{(el archivo $i$ debe estar en un solo disco)}\\
	& \sum_{i = 1}^{n} s_{i} x_{ij} \le d\cdot y_{j} \qquad \forall j \in \{1, \ldots, m\},\ \text{(archivos que entran en el disco $j$)}\\
	& \sum_{i = 1}^{n} x_{ij} \le n\cdot y_{j} \qquad \forall j \in \{1, \ldots, m\},\ \text{(no se puede usar un disco vacío)}\\
	& x_{ij} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\}, \ \forall j \in \{1, \ldots, m\}\\
	& y_{j} \in \{0,1\}, \quad \forall j \in \{1, \ldots, m\}
\end{alignat*}

\subsection{Modelo Zimpl}

A continuación presentamos el modelo Zimpl, con los comentarios
correspondientes que indican la relación con el modelo lineal de la sección
anterior.

\newpage
\lstinputlisting[inputencoding=utf8/latin1]{primera-parte/big_data.zpl}

\newpage
\subsection{Modelo PySCIPOpt}

Como parte del trabajo, incluimos una implementación del modelo utilizando
Python, con la librería PySCIPOpt. La siguiente implementación corresponde 
a una función equivalente al código presentado con Zimpl.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/big_data.py}

\newpage

Esta función recibe los datos leídos de un archivo de configuración creado 
con datos aleatorios, implementado con Python. El siguiente código 
muestra las funciones necesarias para generar este archivo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/configuracion_1.py}

\newpage

La solución incluye un script ejecutable que recibe como parámetro el nombre del 
archivo a generar, genera el archivo y calcula el resultado del modelo. Luego, 
genera el output correspondiente.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/big_data_main.py}

\newpage

Utilizamos las siguientes funciones para generar el output.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/generador_output_1.py}

\newpage
\section{Segunda parte}

\subsection{Introducción}

Se asigna un indicador de importancia $I$ a cada archivo según
características como sensibilidad, frecuencia de uso, y rareza. El
objetivo es encontrar un subconjunto de archivos que quepan en un disco
de tamaño $d$, y que la suma de indicadores de importancia sea máxima.

\subsection{Modelo Lineal}

Para maximizar la importancia de los archivos en un disco, usamos una
variable binaria $x_i$ que indica si el archivo $i$ está o no en el
disco, y la multiplicamos por la constante $I_{i}$ que indica la
importancia del archivo $i$. La restricción que utilizamos para este
problema lineal, es que la suma de los tamaños de los archivos no superen
el tamaño del disco. 

$F$: conjunto de nombres de $i$ archivos, con $i = 1, \ldots, n$. \\

$s_{i}$: tamaño del archivo $i$ en MB, con $i = 1, \ldots, n$. \\

$I_i$ constante: indicador de importancia para el archivo $i$, con $i = 1, \ldots, n$. \\

$n$: cantidad de archivos. \\

$d$: tamaño del disco en TB. \\ 

$x_{i}$ binaria: $1$ indica si el archivo $i$ está en el disco, $\forall i = \{1, \ldots, n\}$, donde $x_{i} \in \{0, 1\}$, $0$ en el caso de que no esté\\

\begin{alignat*}{2}
	\maximize
	& \sum_{i = 1}^{n} I_{i} \cdot x_{i}\\
	\subjto
	& \sum_{i = 1}^{n} s_{i} x_{i} \le d,\ \quad\text{(archivos que entran en el disco)}\\
	& x_{i} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\}
\end{alignat*}

\newpage
\subsection{Modelo Zimpl}

A continuación presentamos el modelo Zimpl, con los comentarios correspondientes que indican la relación con el modelo lineal de la sección anterior.

\lstinputlisting[inputencoding=utf8/latin1]{segunda-parte/importance.zpl}

\newpage
\subsection{Modelo PySCIPOpt}

De la misma manera que en el modelo anterior, generamos el modelo, la configuración y los 
archivos de output utilizando Python.

El modelo es el siguiente.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/importance.py}

\newpage

Los archivos de configuración se generan de manera similar al modelo previo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/configuracion_2.py}

\newpage

El script ejecutable realiza los mismos pasos que el del modelo anterior, pero, considerando 
la importancia de cada archivo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/importance-main.py}

\newpage

Luego, el output se almacena de la siguiente manera.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/generador_output_2.py}

%\newpage
\section{Tercera parte}

TODO

\section{Cuarta parte}

\subsection{Introducción}

Se deben realizar backups de $n$ archivos en discos idénticos de
capacidad $d$.  Se sabe que los archivos son de pocos tamaños distintos,
y que cada archivo es menor que la capacidad de un disco. Se necesita
saber cuál es la cantidad mínima de discos necesarios para almacenar
todos los archivos, considerando la capacidad de cada disco y los
tamaños de archivos.

\subsection{Modelo Lineal}

$F$: conjunto de nombres de cada archivo $i$, con $i = 1, \ldots, n$. \\

$n$: cantidad de archivos. \\

$S$: conjunto de tamaños de cada archivo $i$, con $i = 1, \ldots, n$. \\

$s_{k}$: tamaño $k$ en MB, con $k = 1, \ldots, q$. \\

$q$: cantidad de tamaños. \\

$m$: cantidad de discos disponibles, a lo sumo, un disco por archivo, $m = n$. \\

$D$: conjunto de $j$ discos de tamaño $d$, con $j = 1, \ldots, m$. \\

$d$: tamaño del disco en TB. \\ 

$c_{kj}$: cantidad de archivos de tamaño $k$ que entran en el disco $j$, $\forall k = \{1, \ldots, q\},\ \forall j = \{1, \ldots, m\}$, donde $c_{kj} \ge 0$\\

$y_{j}$ binaria: $1$ indica que se está usando el disco $j$.

\begin{alignat*}{2}
	\minimize
	& \sum_{j = 1}^{m} y_{j}\\
	\subjto
	& \sum_{k = 1}^{q} c_{kj} \ge 1 \qquad \forall j \in \{1, \ldots, m\},\ \text{(no puede haber discos usados con cero cantidad de archivos)}\\
	& \sum_{k = 1}^{q} s_{k} c_{kj} \le d\cdot y_{j} \qquad \forall j \in \{1, \ldots, m\},\ \text{(cantidad de archivos de que entran en el disco $j$)}\\
	& \sum_{k = 1}^{q} c_{kj} \le n\cdot y_{j} \qquad \forall j \in \{1, \ldots, m\},\ \text{(no se pueden entrar más de $n$ archivos por disco)}\\
	& c_{kj} \in \mathds{Z}_{\ge 0}, \quad \forall k \in \{1, \ldots, q\}, \ \forall j \in \{1, \ldots, m\}\\
	& y_{j} \in \{0,1\}, \quad \forall j \in \{1, \ldots, m\}
\end{alignat*}

\section{Conclusiones}

Logramos familiarizarnos con el uso de SCIP, tanto desde su interfaz en
Python mediante PySCIPOpt, como a través del uso de Zimpl directamente
en el solver de SCIP. Este proceso nos ayudó a familiarizarnos con la
parte práctica del solver y con las herramientas de modelado vistas en
la materia.

Por otro lado, tuvimos que sortear distintas dificultades,
principalmente la instalación de estas nuevas tecnologías. Al mismo
tiempo, reforzamos la capacidad para resolver problemas utilizando la
documentación oficial como recurso principal y aclarar dudas a partir de
ella. Esperamos con ansias las siguientes partes.

%\newpage
\begin{thebibliography}{99}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\bibitem{koch}
	%author:
	Koch, T.\
	%date:
	(2024)
	%title:
	\emph{Zimpl User Guide},
	%place and publisher:
	Berlin: ZIB.
	%pages:
	% pp.~43--64.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{thebibliography}

\end{document}
