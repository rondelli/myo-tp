\pdfoutput=1
\pdfpageattr{/Group << /S /Transparency /I true /CS /DeviceRGB>>}
\documentclass[11pt, a4paper, pdftex]{article}

\usepackage[british,spanish,es-minimal,es-sloppy]{babel}
\usepackage{verbatim}

\usepackage[hscale=0.75, vscale=0.70, vmarginratio=1:1,verbose]{geometry}

\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage[scaled=.80]{beramono}
%\usepackage{inconsolata}
%\usepackage{palatino}

\usepackage[safe,tone,extra]{tipa}
\usepackage{mflogo}

\usepackage{graphicx}
	\DeclareGraphicsRule{*}{mps}{*}{}

\usepackage{xcolor}
\usepackage{colortbl}

\usepackage{tikz} % no tiene opciones
	\usetikzlibrary{calc}
	\usetikzlibrary{arrows}
	\usetikzlibrary{backgrounds}
	\usetikzlibrary{decorations.pathmorphing}
	\usetikzlibrary{shapes.geometric}
	\tikzset{>=latex'}

\usepackage{pgfplots}
\usetikzlibrary{pgfplots.dateplot}

%\usepackage{gnuplot-lua-tikz} %para incluir gráficos de gnuplot usando el driver de TikZ

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{nicefrac}
\usepackage{mathrsfs}
\usepackage[Euler]{upgreek}
\usepackage[nointegrals]{wasysym}
\usepackage[version=3,arrows=pgf]{mhchem}
\usepackage[colorlinks,verbose]{hyperref}
	\hypersetup{bookmarksnumbered, bookmarksopen, bookmarksopenlevel=2}
	\hypersetup{pdfstartview=FitH}
	%\hypersetup{pdfpagelayout=TwoColumnRight}

\usepackage{booktabs}

\usepackage{listings}
	%\lstset{showspaces=true,showtabs=true,tab=\rightarrowfill} % DEBUGGING IT!
	\lstloadlanguages{Java,Python,[LaTeX]TeX}

	%\lstset{language=Java} %\lstset{language={[LaTeX]TeX}}
	\lstset{backgroundcolor=\color{blue!5}}
	\lstset{ % set number
		numbers=left,
		stepnumber=1,
		numberstyle=\tiny\color{black!50},
		numbersep=5pt
	}
	\lstset{
		%basewidth={0.65em,0.45em}, % ugly! see documentation for details!
		columns={[c]fullflexible}, % kind of acceptable ;)
		tabsize=5,
		showstringspaces=false,
		%basicstyle=\footnotesize\ttfamily,
		basicstyle=\ttfamily,
		keywordstyle=\bfseries\color{blue!50!black},
		%identifierstyle=\color{blue!75},
		stringstyle=\color{green!50!black},
		commentstyle=\slshape\color{black!50},
		%mathescape=true;
		%morecomment=[is]{/*}{*/}
	}
	%\renewcommand{\lstlistingname}{Fitting}
	%\lstset{basicstyle=\footnotesize\ttfamily}
	%\lstset{numbers=left, numberstyle=\tiny, numbersep=6pt}
	%\lstset{backgroundcolor=\color{blue!10}}
	%\lstset{captionpos=b}
	%\lstset{xleftmargin=16pt}

\usepackage{listingsutf8}

\usepackage{float}

\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{examp}{Ejemplo}[section]
\newenvironment{example}{\begin{examp} \upshape}{$\blacklozenge$ \end{examp}}

\newtheorem{obs}{Observación}[section]
\newenvironment{observation}{\begin{obs} \upshape}{$\blacktriangle$ \end{obs}}

\newtheorem{algor}{Algoritmo}[section]
\newenvironment{algorithm}{\begin{algor} \upshape}{$\blacksquare$ \end{algor}}

\newtheorem{law}{Ley}[section]

\newenvironment{ok}{\renewcommand{\labelitemi}{$\surd$}\begin{itemize}}{\end{itemize}}
\newenvironment{not:ok}{\renewcommand{\labelitemi}{$\times$}\begin{itemize}}{\end{itemize}}

\newcommand{\eg}{e.g.~}
\newcommand{\ie}{i.e.~}

\newcommand{\Emph}[1]{\textsc{#1}}
%\newcommand{\Vec}[1]{\mathbf{#1}}
\newcommand{\oldstyle}[1]{\ensuremath{\mathnormal{#1}}}

\newcommand{\differential}[1]{\:d#1}
\newcommand{\Power}{\mathscr{P}}

% Unit vectors
\newcommand{\iunitvec}{\hat{\imath}}
\newcommand{\junitvec}{\hat{\jmath}}
\newcommand{\kunitvec}{\hat{k}}
\newcommand{\unitvec}[1]{\hat{#1}}
\newcommand{\Unitvec}[1]{\widehat{#1}}

\renewcommand{\labelenumi}{(\roman{enumi})}

\newcounter{BloodyArabic}
\newcommand{\RomanNumber}[1]{\setcounter{BloodyArabic}{#1}\textsc{\roman{BloodyArabic}}}
\newcommand{\rungnuplot}[1]{\immediate\write18{cd ../plots; gnuplot #1.gp && mpost -tex=latex #1.mp}}
\newcommand{\mtopgf}[1]{\immediate\write18{m4 #1.m4 | dpic -g > #1.tex}}

\def\Lucifer{Hernán Rondelli}
\def\Xime{Ximena Ebertz}
\def\Lu{Lucía Soria}
\def\Mati{Matías Curcio}

\title{
	\huge MyO -- Trabajo Práctico\\
}
\author{
	\Mati \and \Xime \and \Lucifer \and \Lu
}
\date{\small $\text{2}^{\text{do}}$ Semestre 2024
}

\flushbottom
\begin{document}

\renewcommand{\contentsname}{Contenidos}
\renewcommand{\listfigurename}{Listado de Figuras}
\renewcommand{\listtablename}{Listado de Tablas}
\renewcommand{\tablename}{Tabla}

\newcommand{\minimize}{\texttt{Minimize}\quad\,\,}
\newcommand{\maximize}{\texttt{Maximize}\quad\,\,}
\newcommand{\subjto}{\texttt{Subject to}\quad}

\pdfbookmark{Título}{title}\maketitle

\tableofcontents

\newpage
\section{Primera parte}

\subsection{Introducción}

Se deben realizar backups de $n$ archivos de la empresa \emph{BigData}
en discos idénticos de capacidad $d$, sin dividir los archivos. Cada
archivo es menor que la capacidad de un disco. Se necesita saber cuál es
la cantidad mínima de discos necesarios para almacenar todos los
archivos, considerando la capacidad de cada disco y el tamaño de cada
archivo. 

\subsection{Modelo Lineal}\label{modelo:primera:parte}

Para minimizar la cantidad de discos, usamos una variable binaria
$y_{j}$ que nos indica si se está usando el disco $j$ o no, y otra
variable binaria $x_{ij}$ para identificar si cada archivo $i$ se guarda
en el disco $j$. Luego, establecimos dos restricciones: la primera se
asegura de que cada archivo esté en un solo disco, y la segunda, que los
tamaños de los archivos de cada disco no superen la capacidad del disco.
%y la tercera define que no se usen discos vacíos---sería equivalente a
%la implicación $x_{ij} \Rightarrow y_i$.

$F$: conjunto de nombres de cada archivo $i$, con $i = 1, \ldots, n$. \\

$s_{i}$: tamaño del archivo $i$ en MB, con $i = 1, \ldots, n$. \\

$n$: cantidad de archivos. \\

$m$: cantidad de discos disponibles, a lo sumo, un archivo por disco, $m = n$. \\

$D$: conjunto de $j$ discos de tamaño $d$, con $j = 1, \ldots, m$. \\

$d$: tamaño del disco en TB. \\ 

$x_{ij}$ binaria: $1$ indica si el archivo $i$ está en el disco $j$, $\forall i = \{1, \ldots, n\},\ \forall j = \{1, \ldots, m\}$, donde $x_{ij} \in \{0, 1\}$, $0$ en el caso de que no esté\\

$y_{j}$ binaria: $1$ indica que se está usando el disco $j$.

\begin{alignat*}{2}
	\minimize
	& \sum_{j = 1}^{m} y_{j}\\
	\subjto
	& \sum_{j = 1}^{m} x_{ij} = 1 \quad \forall i \in \{1, \ldots, n\},\ \text{(el archivo $i$ debe estar en un solo disco)}\\
	& \sum_{i = 1}^{n} s_{i} x_{ij} \le d\cdot y_{j} \quad \forall j \in \{1, \ldots, m\},\ \text{(los archivos que entran en el disco $j$)}\\
	% & \sum_{i = 1}^{n} x_{ij} \le n\cdot y_{j} \qquad \forall j \in \{1, \ldots, m\},\ \text{(no se puede usar un disco vacío)}\\
	& x_{ij} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\}, \ \forall j \in \{1, \ldots, m\}\\
	& y_{j} \in \{0,1\}, \quad \forall j \in \{1, \ldots, m\}
\end{alignat*}

\subsubsection{Restricción: que no se elijan discos vacíos}

Inicialmente, habíamos planteado el programa lineal de la
Sección~\ref{modelo:primera:parte} con una tercera restricción:
\begin{alignat*}{2}
    \sum_{i = 1}^{n} x_{ij} \le n\cdot y_{j} \quad \forall j \in \{1,
	\ldots, m\},\ \text{(no se puede usar un disco vacío)}
\end{alignat*}
En esta sección, explicamos porqué esta restricción---aunque no
modificaba el resultado de la función objetivo---no es necesaria,
mediante una demostración por el absurdo.

Supongamos que contamos con dos archivos $f_{1}$ y $f_{2}$, y dos
discos, $d_{1}$ y $d_{2}$. En este caso, una solución óptima hipotética
sería $y = (1, 1)$, que indica que se utilizan los dos discos.

Supongamos que esta solución considera que los archivos $f_{1}$ y
$f_{2}$ se almacenan en el disco $d_{2}$ (considerando que ambos
archivos entran en el disco), quedando el disco $d_{1}$ vacío. Si
analizamos las restricciones, vemos que todas se cumplen. Es decir:
\begin{alignat}{2}
	& \sum_{j = 1}^{2} x_{ij} = 1                     & \qquad \forall i \in \{1, 2\}\label{coso:de:mas:1}\\
	& \sum_{i = 1}^{2} s_{i} x_{ij} \le d \cdot y_{j} & \qquad \forall j \in \{1, 2\}\label{coso:de:mas:2}
\end{alignat}
Vemos que \eqref{coso:de:mas:1} se cumple ya que ambos archivos $f_{1}$ y
$f_{2}$ están en un sólo disco, $d_{2}$, por hipótesis. Por otro lado,
\eqref{coso:de:mas:2} se cumple, ya que\ldots
\begin{enumerate}
	\item $0 \leq d_{1} \cdot 1$, ya que el disco está vacío.
	\item $s_{1} + s_{2} \leq d_{2} \cdot 1$, por hipótesis.
\end{enumerate}
A parte, notar que $x_{ij} \in \{0,1\},\ \forall i \in \{1, 2\},\ \forall j \in \{1, 2\}$,
y $y_{j} \in \{0,1\},\ \forall j \in \{1, 2\}$ por hipótesis. % mmm jajajsj

Queremos ver, a partir de esto, que existe una solución $x^{*}$ mejor,
por lo que $x$ no sería una solución óptima.

Consideremos la solución $x^{*} = (0, 1)$. Vemos que también se cumplen las
restricciones:
\begin{alignat}{2}
	& \sum_{j = 1}^{2} x_{ij} = 1                     &\qquad \forall i \in \{1, 2\}\label{otro:coso:de:mas:1}\\
	& \sum_{i = 1}^{2} s_{i} x_{ij} \le d \cdot y_{j} &\qquad \forall j \in \{1, 2\}\label{otro:coso:de:mas:2}
\end{alignat}
en \eqref{otro:coso:de:mas:1} se cumple ya que ambos archivos $f_{1}$ y
$f_{2}$ están en un sólo disco, $d_{2}$, por hipótesis, y
\eqref{otro:coso:de:mas:2} se cumple, ya que\ldots
\begin{enumerate}
	\item $0 \leq d_{1} \cdot 0$, ya que no se elige el disco 1.
	\item $s_{1} + s_{2} \leq d_{2} \cdot 1$, por hipótesis.
\end{enumerate}

También se cumplen las condiciones con respecto a los valores que pueden
tomar $x_{1, j}$ e $y_{j}$, ya que no fueron modificadas. Entonces,
$x^{*}$ es una solución factible.

Para $x$,
\begin{displaymath}
	\sum_{j = 1}^{m} y_{j} = 2.
\end{displaymath}
Por otra parte, para $x^{*}$,
\begin{displaymath}
	\sum_{j = 1}^{m} y_{j} = 1.
\end{displaymath}

Entonces, $x^{*}$ es una mejor solución que $x$, por lo que $x$ no puede
ser una solución óptima. Este absurdo surgió de considerar que puede
haber un disco vacío en una solución óptima de nuestro problema lineal.
Esto implica que la restricción planteada no aporta valor al problema,
ya que probamos que se llega a una solución correcta sin ella.

\newpage

\subsection{Modelo Zimpl}

A continuación presentamos el modelo Zimpl, con los comentarios
correspondientes que indican la relación con el modelo lineal de la sección
anterior.

\lstinputlisting[inputencoding=utf8/latin1]{primera-parte/big_data.zpl}

\newpage
\subsection{Modelo PySCIPOpt}

Como parte del trabajo, incluimos una implementación del modelo utilizando
Python, con la librería PySCIPOpt. La siguiente implementación corresponde 
a una función equivalente al código presentado con Zimpl.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/big_data.py}

\newpage

Esta función recibe los datos leídos de un archivo de configuración creado 
con datos aleatorios. El siguiente código muestra las funciones necesarias para generar este archivo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/configuracion_1.py}

\newpage

La solución incluye un script ejecutable que recibe como parámetro el nombre del 
archivo a generar, genera el archivo y calcula el resultado del modelo. Luego, 
genera el output correspondiente.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/big_data_main.py}

\newpage

Utilizamos las siguientes funciones para generar el output.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{primera-parte/generador_output_1.py}

\newpage
\section{Segunda parte}

\subsection{Introducción}

Se asigna un indicador de importancia $I$ a cada archivo según
características como sensibilidad, frecuencia de uso, y rareza. El
objetivo es encontrar un subconjunto de archivos que quepan en un disco
de tamaño $d$, y que la suma de indicadores de importancia sea máxima.

\subsection{Modelo Lineal}

Para maximizar la importancia de los archivos en un disco, usamos una
variable binaria $x_i$ que indica si el archivo $i$ está o no en el
disco, y la multiplicamos por la constante $I_{i}$ que indica la
importancia del archivo $i$. La restricción que utilizamos para este
problema lineal, es que la suma de los tamaños de los archivos no superen
el tamaño del disco. 

$F$: conjunto de nombres de $i$ archivos, con $i = 1, \ldots, n$. \\

$s_{i}$: tamaño del archivo $i$ en MB, con $i = 1, \ldots, n$. \\

$I_i$ constante: indicador de importancia para el archivo $i$, con $i = 1, \ldots, n$. \\

$n$: cantidad de archivos. \\

$d$: tamaño del disco en TB. \\ 

$x_{i}$ binaria: $1$ indica si el archivo $i$ está en el disco, $\forall i = \{1, \ldots, n\}$, donde $x_{i} \in \{0, 1\}$, $0$ en el caso de que no esté\\

\begin{alignat*}{2}
	\maximize
	& \sum_{i = 1}^{n} I_{i} \cdot x_{i}\\
	\subjto
	& \sum_{i = 1}^{n} s_{i} x_{i} \le d,\ \quad\text{(archivos que entran en el disco)}\\
	& x_{i} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\}
\end{alignat*}

\newpage
\subsection{Modelo Zimpl}

A continuación presentamos el modelo Zimpl, con los comentarios correspondientes que indican la relación con el modelo lineal de la sección anterior.

\lstinputlisting[inputencoding=utf8/latin1]{segunda-parte/importance.zpl}

\newpage
\subsection{Modelo PySCIPOpt}

De la misma manera que en el modelo anterior, generamos el modelo, la configuración y los 
archivos de output utilizando Python.

El modelo es el siguiente.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/importance.py}

\newpage

Los archivos de configuración se generan de manera similar al modelo previo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/configuracion_2.py}

\newpage

El script ejecutable realiza los mismos pasos que el del modelo anterior, pero, considerando 
la importancia de cada archivo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/importance-main.py}

\newpage

Luego, el output se almacena de la siguiente manera.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{segunda-parte/generador_output_2.py}

%\newpage
\section{Tercera parte}

\subsection{Introducción}

Dado un conjunto de archivos $C$ y una familia de conjuntos $H$, donde
$H \subseteq C$ y cada archivo de $C$ pertenece a algún conjunto de $H$,
se busca un subconjunto mínimo $I \subseteq H$ tal que todos los
archivos de $C$ estén cubiertos por al menos un conjunto de $I$.

\subsection{Modelo Lineal}

$n$: cantidad de archivos. \\

$m$: cantidad de conjuntos \( H \). \\

$x_{j}$ binaria: $1$ indica que el conjunto $H_{j}$ pertenece a $I$. \\ 

$y_{ij}$ \textbf{constante} binaria: $1$ indica que el conjunto $H_{j}$
contiene el archivo $i$. \\ 

\begin{alignat*}{2}
    \minimize & \sum_{j = 1}^{m} x_{j}\\
    \subjto   & \sum_{j=1}^{m} y_{i,j} \cdot x_j \geq 1 \quad \forall i,\ \text{(todos los archivos deben estar en al menos un conjunto elegido)}\\
              & \sum_{i=1}^{n} y_{i,j} \geq x_j \quad \forall j,\ \text{(todos los conjuntos elegidos deben tener al menos un archivo)}
\end{alignat*}

\section{Cuarta parte}

\subsection{Introducción}

Se deben realizar backups de $n$ archivos en discos idénticos de
capacidad $d$.  Se sabe que los archivos son de pocos tamaños distintos,
y que cada archivo es menor que la capacidad de un disco. Se necesita
saber cuál es la cantidad mínima de discos necesarios para almacenar
todos los archivos, considerando la capacidad de cada disco y los
tamaños de archivos.

\subsection{Modelo Lineal}



$F$: conjunto de nombres de cada archivo $i$, con $i = 1, \ldots, n$. \\

$n$: cantidad de archivos. \\

$S$: conjunto de tamaños de cada archivo $i$, con $i = 1, \ldots, n$. \\

$s_{k}$: tamaño $k$ en MB, con $k = 1, \ldots, q$. \\

$q$: cantidad de tamaños. \\

$m$: cantidad de discos disponibles, a lo sumo, un disco por archivo, $m = n$. \\

$D$: conjunto de $j$ discos de tamaño $d$, con $j = 1, \ldots, m$. \\

$d$: tamaño del disco en TB. \\ 

$x_{ij}$ binaria: $1$ indica si el archivo $i$ está en el disco $j$, $\forall i = \{1, \ldots, n\},\ \forall j = \{1, \ldots, m\}$, donde $x_{ij} \in \{0, 1\}$, $0$ en el caso de que no esté\\

$c_{kj}$: cantidad de archivos de tamaño $k$ que entran en el disco $j$, $\forall k = \{1, \ldots, q\},\ \forall j = \{1, \ldots, m\}$, donde $c_{kj} \ge 0$\\

$y_{j}$ binaria: $1$ indica que se está usando el disco $j$.

\begin{alignat*}{2}
	\minimize
	& \sum_{j = 1}^{m} y_{j}\\
	\subjto
	& \sum_{j = 1}^{m} x_{ij} = 1 \quad \forall i \in \{1, \ldots, n\},\ \text{(el archivo $i$ debe estar en un solo disco)}\\
	& \sum_{i = 1}^{n} s_{i} x_{ij} \le d\cdot y_{j} \quad \forall j \in \{1, \ldots, m\},\ \text{(los archivos que entran en el disco $j$)}\\
	& \sum_{k = 1}^{q} c_{kj} \ge 1 \quad \forall j \in \{1, \ldots, m\},\ \text{(no pueden haber discos con cero cantidad de archivos)}\\
	& \sum_{k = 1}^{q} s_{k} c_{kj} \le d\cdot y_{j} \quad \forall j \in \{1, \ldots, m\},\ \text{(cantidad de archivos de que entran en el disco $j$)}\\
	% esta restricción está de más
	% & \sum_{k = 1}^{q} c_{kj} \le n\cdot y_{j} \qquad \forall j \in \{1, \ldots, m\},\ \text{(no pueden entrar más de $n$ archivos por disco)}\\
	& c_{kj} \in \mathds{Z}_{\ge 0}, \quad \forall k \in \{1, \ldots, q\}, \ \forall j \in \{1, \ldots, m\}\\
	& y_{j} \in \{0,1\}, \quad \forall j \in \{1, \ldots, m\}
\end{alignat*}

\section{Conclusiones}

Logramos familiarizarnos con el uso de SCIP, tanto desde su interfaz en
Python mediante PySCIPOpt, como a través del uso de Zimpl directamente
en el solver de SCIP. Este proceso nos ayudó a familiarizarnos con la
parte práctica del solver y con las herramientas de modelado vistas en
la materia.

Por otro lado, tuvimos que sortear distintas dificultades,
principalmente la instalación de estas nuevas tecnologías. Al mismo
tiempo, reforzamos la capacidad para resolver problemas utilizando la
documentación oficial como recurso principal y aclarar dudas a partir de
ella. Esperamos con ansias las siguientes partes.

%\newpage
\begin{thebibliography}{99}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\bibitem{koch}
	%author:
	Koch, T.\
	%date:
	(2024)
	%title:
	\emph{Zimpl User Guide},
	%place and publisher:
	Berlin: ZIB.
	%pages:
	% pp.~43--64.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{thebibliography}

\end{document}
