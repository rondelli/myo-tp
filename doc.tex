\pdfoutput=1
\pdfpageattr{/Group << /S /Transparency /I true /CS /DeviceRGB>>}
\documentclass[11pt, a4paper, pdftex]{article}

\usepackage[british,spanish,es-minimal,es-sloppy]{babel}
\usepackage{verbatim}

\usepackage[hscale=0.75, vscale=0.70, vmarginratio=1:1,verbose]{geometry}
%\usepackage[left=0.5cm]{geometry}
\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage[scaled=.80]{beramono}
%\usepackage{inconsolata}
%\usepackage{palatino}

\usepackage[safe,tone,extra]{tipa}
\usepackage{mflogo}

\usepackage{graphicx}
	\DeclareGraphicsRule{*}{mps}{*}{}

\usepackage{xcolor}
\usepackage{colortbl}

\usepackage{rotating}
\usepackage{lscape}

\usepackage{tikz} % no tiene opciones
	\usetikzlibrary{calc}
	\usetikzlibrary{arrows}
	\usetikzlibrary{backgrounds}
	\usetikzlibrary{decorations.pathmorphing}
	\usetikzlibrary{shapes.geometric}
	\tikzset{>=latex'}

\usepackage{pgfplots}
\usetikzlibrary{pgfplots.dateplot}

%\usepackage{gnuplot-lua-tikz} %para incluir gráficos de gnuplot usando el driver de TikZ

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{nicefrac}
\usepackage{mathrsfs}
\usepackage[Euler]{upgreek}
\usepackage[nointegrals]{wasysym}
\usepackage[version=3,arrows=pgf]{mhchem}
\usepackage[colorlinks,verbose]{hyperref}
	\hypersetup{bookmarksnumbered, bookmarksopen, bookmarksopenlevel=2}
	\hypersetup{pdfstartview=FitH}
	%\hypersetup{pdfpagelayout=TwoColumnRight}

\usepackage{booktabs}

\usepackage{listings}
	%\lstset{showspaces=true,showtabs=true,tab=\rightarrowfill} % DEBUGGING IT!
	\lstloadlanguages{Java,Python,[LaTeX]TeX}

	%\lstset{language=Java} %\lstset{language={[LaTeX]TeX}}
	\lstset{backgroundcolor=\color{blue!5}}
	\lstset{ % set number
		numbers=left,
		stepnumber=1,
		numberstyle=\tiny\color{black!50},
		numbersep=5pt
	}
	\lstset{
		%basewidth={0.65em,0.45em}, % ugly! see documentation for details!
		columns={[c]fullflexible}, % kind of acceptable ;)
		tabsize=5,
		showstringspaces=false,
		%basicstyle=\footnotesize\ttfamily,
		basicstyle=\ttfamily,
		keywordstyle=\bfseries\color{blue!50!black},
		%identifierstyle=\color{blue!75},
		stringstyle=\color{green!50!black},
		commentstyle=\slshape\color{black!50},
            breaklines=true, 
		%mathescape=true;
		%morecomment=[is]{/*}{*/}
	}
	%\renewcommand{\lstlistingname}{Fitting}
	%\lstset{basicstyle=\footnotesize\ttfamily}
	%\lstset{numbers=left, numberstyle=\tiny, numbersep=6pt}
	%\lstset{backgroundcolor=\color{blue!10}}
	%\lstset{captionpos=b}
	%\lstset{xleftmargin=16pt}

\usepackage{listingsutf8}

\usepackage{float}

\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{examp}{Ejemplo}[section]
\newenvironment{example}{\begin{examp} \upshape}{$\blacklozenge$ \end{examp}}

\newtheorem{obs}{Observación}[section]
\newenvironment{observation}{\begin{obs} \upshape}{$\blacktriangle$ \end{obs}}

\newtheorem{algor}{Algoritmo}[section]
\newenvironment{algorithm}{\begin{algor} \upshape}{$\blacksquare$ \end{algor}}

\newtheorem{law}{Ley}[section]

\newenvironment{ok}{\renewcommand{\labelitemi}{$\surd$}\begin{itemize}}{\end{itemize}}
\newenvironment{not:ok}{\renewcommand{\labelitemi}{$\times$}\begin{itemize}}{\end{itemize}}

\newcommand{\eg}{e.g.~}
\newcommand{\ie}{i.e.~}

\newcommand{\Emph}[1]{\textsc{#1}}
%\newcommand{\Vec}[1]{\mathbf{#1}}
\newcommand{\oldstyle}[1]{\ensuremath{\mathnormal{#1}}}

\newcommand{\differential}[1]{\:d#1}
\newcommand{\Power}{\mathscr{P}}

% Unit vectors
\newcommand{\iunitvec}{\hat{\imath}}
\newcommand{\junitvec}{\hat{\jmath}}
\newcommand{\kunitvec}{\hat{k}}
\newcommand{\unitvec}[1]{\hat{#1}}
\newcommand{\Unitvec}[1]{\widehat{#1}}

\renewcommand{\labelenumi}{(\roman{enumi})}

\newcounter{BloodyArabic}
\newcommand{\RomanNumber}[1]{\setcounter{BloodyArabic}{#1}\textsc{\roman{BloodyArabic}}}
\newcommand{\rungnuplot}[1]{\immediate\write18{cd ../plots; gnuplot #1.gp && mpost -tex=latex #1.mp}}
\newcommand{\mtopgf}[1]{\immediate\write18{m4 #1.m4 | dpic -g > #1.tex}}

\def\Lucifer{Hernán Rondelli}
\def\Xime{Ximena Ebertz}
\def\Lu{Lucía Soria}
\def\Mati{Matías Curcio}

\title{
	\huge Modelado y Optimización -- Trabajo Práctico\\
}
\author{
	\Xime \and \Lucifer \and \Lu
}
\date{\small $\text{2}^{\text{do}}$ Semestre 2024
}

\flushbottom
\begin{document}

\renewcommand{\contentsname}{Contenidos}
\renewcommand{\listfigurename}{Listado de Figuras}
\renewcommand{\listtablename}{Listado de Tablas}
\renewcommand{\tablename}{Tabla}

\newcommand{\minimize}{\texttt{Minimize}\quad\,\,}
\newcommand{\maximize}{\texttt{Maximize}\quad\,\,}
\newcommand{\subjto}{\texttt{Subject to}\quad}

\pdfbookmark{Título}{title}\maketitle

\tableofcontents

\newpage

\section{Introducción}

Este trabajo práctico tiene como objetivo aplicar conceptos de modelado
y de optimización, utilizando técnicas de programación lineal, y distintas
tecnologías y herramientas. Buscamos, a través de una serie de problemas
relacionados con la gestión de archivos en una empresa de datos, diseñar
soluciones eficientes que optimicen el uso de recursos, como el
almacenamiento en discos y la importancia de los datos.

La actividad se divide en seis partes, cada una con enfoques específicos
que abarcan desde el modelado directo en \verb|SCIP|, hasta la
implementación de algoritmos en Python con la biblioteca
\verb|PySCIPOpt|. A lo largo de este trabajo, se considerarán restricciones
como la capacidad limitada de los discos, la importancia de los archivos,
y la estructura de conjuntos para maximizar la eficiencia del
almacenamiento y la relevancia de los datos seleccionados.

\newpage
\section{Parte 1}\label{primera:parte}

\subsection{Descripción}

Se deben realizar backups de $n$ archivos de la empresa \emph{BigData}
en discos idénticos de capacidad $d$, sin dividir los archivos. Cada
archivo es menor que la capacidad de un disco. Se necesita saber cuál es
la cantidad mínima de discos necesarios para almacenar todos los
archivos, considerando la capacidad de cada disco y el tamaño de cada
archivo. 

\subsection{Modelo Lineal}\label{modelo:primera:parte}

Para minimizar la cantidad de discos, usamos una variable binaria
$y_{j}$ que nos indica si se está usando el disco $j$ o no, y otra
variable binaria $x_{ij}$ para identificar si cada archivo $i$ se guarda
en el disco $j$. Luego, establecimos dos restricciones: la primera se
asegura de que cada archivo esté en un solo disco, y la segunda, que los
tamaños de los archivos de cada disco no superen la capacidad del disco.


\subsubsection{Definición de variables}

\noindent $n$: Constante, cantidad de archivos. \\

\noindent $s_{i}$: Constante, tamaño del archivo $i$ en $\text{MB}$, $\forall i \in \{1, \ldots, n\}$. \\

\noindent $m$: Cantidad de discos disponibles; a lo sumo, un archivo por disco, con $m = n$. \\

\noindent $d$: Constante, tamaño del disco en $\text{TB}$. \\ 

\noindent $x_{ij}$: Variable binaria, donde $x_{ij} = 1$ indica que el archivo $i$ está en el disco $j$, $\forall i \in \{1, \ldots, n\},\ \forall j \in \{1, \ldots, m\}$, con $x_{ij} \in \{0, 1\}$. \\

\noindent $y_{j}$: Variable binaria, donde $y_{j} = 1$ indica que se está usando el disco $j$, $\forall j \in \{1, \ldots, m\}$, con $y_{j} \in \{0, 1\}$. \\


\subsubsection{Modelo}

\begin{alignat*}{2}
	\minimize
	& \sum_{j = 1}^{m} y_{j}\\
	\subjto
	& \sum_{j = 1}^{m} x_{ij} = 1 \quad \forall i \in \{1, \ldots, n\},\ \text{(el archivo $i$ debe estar en un solo disco)}\\
	& \sum_{i = 1}^{n} s_{i} x_{ij} \le d\cdot y_{j} \quad \forall j \in \{1, \ldots, m\},\ \text{(los archivos que entran en el disco $j$)}\\
	% & \sum_{i = 1}^{n} x_{ij} \le n\cdot y_{j} \qquad \forall j \in \{1, \ldots, m\},\ \text{(no se puede usar un disco vacío)}\\
	& x_{ij} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\}, \ \forall j \in \{1, \ldots, m\}\\
	& y_{j} \in \{0,1\}, \quad \forall j \in \{1, \ldots, m\}
\end{alignat*}

\subsubsection{Restricción: que no se elijan discos vacíos}

Inicialmente, habíamos planteado el programa lineal de la
Sección~\ref{modelo:primera:parte} con una tercera restricción:
\begin{alignat*}{2}
    \sum_{i = 1}^{n} x_{ij} \le n\cdot y_{j} \quad \forall j \in \{1,
	\ldots, m\},\ \text{(no se puede usar un disco vacío)}
\end{alignat*}
En esta sección, explicamos porqué esta restricción---aunque no
modificaba el resultado de la función objetivo---no es necesaria,
mediante una demostración por el absurdo.

Supongamos que contamos con dos archivos $f_{1}$ y $f_{2}$, y dos
discos, $d_{1}$ y $d_{2}$. En este caso, una solución óptima hipotética
sería $y = (1, 1)$, que indica que se utilizan los dos discos.

Supongamos que esta solución considera que los archivos $f_{1}$ y
$f_{2}$ se almacenan en el disco $d_{2}$ (considerando que ambos
archivos entran en el disco), quedando el disco $d_{1}$ vacío. Si
analizamos las restricciones, vemos que todas se cumplen. Es decir:
\begin{alignat}{2}
	& \sum_{j = 1}^{2} x_{ij} = 1                     & \qquad \forall i \in \{1, 2\}\label{coso:de:mas:1}\\
	& \sum_{i = 1}^{2} s_{i} x_{ij} \le d \cdot y_{j} & \qquad \forall j \in \{1, 2\}\label{coso:de:mas:2}
\end{alignat}
Vemos que \eqref{coso:de:mas:1} se cumple ya que ambos archivos $f_{1}$ y
$f_{2}$ están en un sólo disco, $d_{2}$, por hipótesis. Por otro lado,
\eqref{coso:de:mas:2} se cumple, ya que\ldots
\begin{enumerate}
	\item $0 \leq d_{1} \cdot 1$, ya que el disco está vacío.
	\item $s_{1} + s_{2} \leq d_{2} \cdot 1$, por hipótesis.
\end{enumerate}
A parte, notar que $x_{ij} \in \{0,1\},\ \forall i \in \{1, 2\},\ \forall j \in \{1, 2\}$,
y $y_{j} \in \{0,1\},\ \forall j \in \{1, 2\}$ por hipótesis. % mmm jajajsj

Queremos ver, a partir de esto, que existe una solución $x^{*}$ mejor,
por lo que $x$ no sería una solución óptima.

Consideremos la solución $x^{*} = (0, 1)$. Vemos que también se cumplen las
restricciones:
\begin{alignat}{2}
	& \sum_{j = 1}^{2} x_{ij} = 1                     &\qquad \forall i \in \{1, 2\}\label{otro:coso:de:mas:1}\\
	& \sum_{i = 1}^{2} s_{i} x_{ij} \le d \cdot y_{j} &\qquad \forall j \in \{1, 2\}\label{otro:coso:de:mas:2}
\end{alignat}
en \eqref{otro:coso:de:mas:1} se cumple ya que ambos archivos $f_{1}$ y
$f_{2}$ están en un sólo disco, $d_{2}$, por hipótesis, y
\eqref{otro:coso:de:mas:2} se cumple, ya que\ldots
\begin{enumerate}
	\item $0 \leq d_{1} \cdot 0$, ya que no se elige el disco 1.
	\item $s_{1} + s_{2} \leq d_{2} \cdot 1$, por hipótesis.
\end{enumerate}

También se cumplen las condiciones con respecto a los valores que pueden
tomar $x_{1, j}$ e $y_{j}$, ya que no fueron modificadas. Entonces,
$x^{*}$ es una solución factible.

Para $x$,
\begin{displaymath}
	\sum_{j = 1}^{m} y_{j} = 2.
\end{displaymath}
Por otra parte, para $x^{*}$,
\begin{displaymath}
	\sum_{j = 1}^{m} y_{j} = 1.
\end{displaymath}

Entonces, $x^{*}$ es una mejor solución que $x$, por lo que $x$ no puede
ser una solución óptima. Este absurdo surgió de considerar que puede
haber un disco vacío en una solución óptima de nuestro problema lineal.
Esto implica que la restricción planteada no aporta valor al problema,
ya que probamos que se llega a una solución correcta sin ella.

\newpage

\subsubsection{Modelo Zimpl}

A continuación presentamos el modelo Zimpl, con los comentarios
correspondientes que indican la relación con el modelo lineal de la sección
anterior.

\lstinputlisting[inputencoding=utf8/latin1]{1_primera_parte/model_part_1.zpl}

\newpage
\subsubsection{Modelo PySCIPOpt}

Como parte del trabajo, incluimos una implementación del modelo utilizando
Python, con la librería PySCIPOpt. La siguiente implementación corresponde 
a una función equivalente al código presentado con Zimpl.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{1_primera_parte/model_part_1.py}

\newpage

Esta función recibe los datos leídos de un archivo de configuración creado 
con datos aleatorios. El siguiente código muestra las funciones necesarias para generar este archivo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python, firstline=7, lastline=8]{utils/inputs.py}
\lstinputlisting[inputencoding=utf8/latin1,language=Python, firstline=22, lastline=58]{utils/inputs.py}

%\newpage

La solución incluye un script ejecutable que recibe como parámetro el nombre del 
archivo a generar, genera el archivo y calcula el resultado del modelo. Luego, 
genera el output correspondiente.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{1_primera_parte/main.py}

\newpage

Utilizamos la siguiente función para generar el output.

\lstinputlisting[inputencoding=utf8/latin1,language=Python, firstline=7, lastline=38]{utils/outputs.py}

\newpage
\section{Parte 2}

\subsection{Descripción}

Se asigna un indicador de importancia $I$ a cada archivo según
características como sensibilidad, frecuencia de uso, y rareza. El
objetivo es encontrar un subconjunto de archivos que quepan en un disco
de tamaño $d$, y que la suma de indicadores de importancia sea máxima.

\subsection{Modelo Lineal}

Para maximizar la importancia de los archivos en un disco, usamos una
variable binaria $x_i$ que indica si el archivo $i$ está o no en el
disco, y la multiplicamos por la constante $I_{i}$ que indica la
importancia del archivo $i$. La restricción que utilizamos para este
problema lineal, es que la suma de los tamaños de los archivos no superen
el tamaño del disco. 

\subsubsection{Definición de variables}

%\noindent $F$: conjunto de nombres de $i$ archivos, con $i = 1, \ldots, n$. \\

\noindent $n$: Constante, cantidad de archivos. \\

\noindent $s_{i}$: Constante, tamaño del archivo $i$ en $\text{MB}$, con $i \in \{1, \ldots, n\}$. \\

\noindent $I_{i}$: Constante, indicador de importancia para el archivo $i$, con $i \in \{1, \ldots, n\}$. \\

\noindent $d$: Constante, tamaño del disco en $\text{TB}$. \\

\noindent $x_{i}$: Variable binaria, donde $x_{i} = 1$ indica que el archivo $i$ está en el disco y $x_{i} = 0$ en caso contrario, con $x_{i} \in \{0, 1\}$, $\forall i \in \{1, \ldots, n\}$. \\


\subsubsection{Modelo}

\begin{alignat*}{2}
	\maximize
	& \sum_{i = 1}^{n} I_{i} \cdot x_{i}\\
	\subjto
	& \sum_{i = 1}^{n} s_{i} x_{i} \le d\ \quad\text{(archivos que entran en el disco)}\\
	& x_{i} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\} \\
        %& s_{i} \geq 0, \quad \forall i \in \{1, \ldots, n\} \\
        %& I_{i} \geq 0, \quad \forall i \in \{1, \ldots, n\} \\
        %& n \geq 0\\
        %& d \geq 0\\
\end{alignat*}

\newpage
\subsubsection{Modelo Zimpl}

A continuación presentamos el modelo Zimpl, con los comentarios correspondientes que indican la relación con el modelo lineal de la sección anterior.

\lstinputlisting[inputencoding=utf8/latin1]{2_segunda_parte/model_part_2.zpl}

\newpage
\subsubsection{Modelo PySCIPOpt}

De la misma manera que en el modelo anterior, generamos el modelo, la configuración y los 
archivos de output utilizando Python.

El modelo es el siguiente.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{2_segunda_parte/model_part_2.py}

\newpage
Los archivos de configuración se generan de manera similar al modelo previo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python, firstline=10, lastline=11]{utils/inputs.py}
\lstinputlisting[inputencoding=utf8/latin1,language=Python, firstline=22, lastline=58]{utils/inputs.py}

\newpage

El script ejecutable realiza los mismos pasos que el del modelo anterior, pero, considerando 
la importancia de cada archivo.

\lstinputlisting[inputencoding=utf8/latin1,language=Python]{2_segunda_parte/main.py}

\newpage

Luego, el output se almacena de la siguiente manera.

\lstinputlisting[inputencoding=utf8/latin1,language=Python, firstline=43, lastline=67]{utils/outputs.py}

\newpage
\section{Parte 3}

\subsection{Descripción}

Dado un conjunto de archivos $C$ y una familia de conjuntos de archivos
$\mathcal{H}$, donde cada conjunto de archivos $H$ de $\mathcal{H}$ está
incluido en $C$, y cada archivo de $C$ pertenece a algún conjunto de la familia
$\mathcal{H}$, se busca un subconjunto mínimo $\mathcal{I}$ de $\mathcal{H}$
tal que todos los archivos de $C$ estén cubiertos por al menos un conjunto de
$\mathcal{I}$.

\subsection{Modelo Lineal}

\subsubsection{Definición de variables}

\noindent $n$: Constante, cantidad de archivos. \\

\noindent $m$: Constante, cantidad de conjuntos $H$. \\

\noindent $y_{ij}$: Constante binaria, donde $y_{ij} = 1$ indica que el conjunto $H_{j}$ contiene el archivo $i$, con $y_{ij} \in \{0, 1\}$, $\forall i \in \{1, \ldots, n\}$, $\forall j \in \{1, \ldots, m\}$. \\

\noindent $x_{j}$: Variable binaria, donde $x_{j} = 1$ indica que el conjunto $H_{j}$ pertenece a $I$, con $x_{j} \in \{0, 1\}$, $\forall j \in \{1, \ldots, m\}$. \\


\subsubsection{Modelo}

\begin{alignat*}{2}
    \minimize & \sum_{j = 1}^{m} x_{j}\\
    \subjto   & \sum_{j=1}^{m} y_{i,j} \cdot x_j \geq 1 \quad \forall i,\ \text{(todos los archivos deben estar en al menos un conjunto elegido)}\\
              %& \sum_{i=1}^{n} y_{i,j} \geq x_j \quad \forall j,\ \text{(todos los conjuntos elegidos deben tener al menos un archivo)}
              & x_{j} \in \{0,1\}, \quad \forall j \in \{1, \ldots, m\} \\
              %& y_{i, j} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\}, \quad \forall j \in \{1, \ldots, m\} \\
              %& n \geq 0, \quad \\
              %& m \geq 0, \quad
\end{alignat*}

\newpage
\section{Parte 4}\label{cuarta:parte}

\subsection{Descripción}

Se deben realizar backups de $n$ archivos en discos idénticos de
capacidad $d$. Se sabe que los archivos son de pocos tamaños distintos,
y que cada archivo es menor que la capacidad de un disco. Se necesita
saber cuál es la cantidad mínima de discos necesarios para almacenar
todos los archivos, considerando la capacidad de cada disco y los
tamaños de archivos.

\subsection{Modelo Lineal}

\subsubsection{Definición de variables}

\noindent $d$, constante: tamaño del disco en TB. \\

\noindent $n$, constante: cantidad de archivos. \\

% \noindent $m$: cantidad de discos disponibles, a lo sumo, un archivo por disco, $m = n$. \\

\noindent $t$, constante: cantidad de tamaños distintos de archivos. \\

\noindent $s_{k}$, constante: tamaño $k$ en MB, con $k \in \{1, \ldots, t\}$. \\

\noindent $f_{k}$, constante: cantidad de archivos de tamaño $k$ en MB, con $k \in \{1, \ldots, t\}$. \\

\noindent $x_{p}$, entera: cantidad de veces que se usa el patrón $p$, con $p \in \{1, \ldots, q\}$, donde $x_{p} \ge 0$. \\

\noindent $c_{kp}$, constante entera: cantidad de archivos de tamaño $k$ que entran en el patrón $p$, con $k \in \{1, \ldots, t\}$ y $p \in \{1, \ldots, q\}$.

% \noindent $y_{j}$ binaria: $1$ indica que se está usando el disco $j$.

\subsubsection{Modelo}

\begin{alignat*}{2}
	\minimize
	& \sum_{p = 1}^{q} x_{p}\\
	\subjto
	& \sum_{k=1}^{t} \sum_{p = 1}^{q}\ s_{k} \cdot c_{kp} \cdot x_{jp} \le d \qquad \text{(tamaño $k$ que entran por disco $d$)}\\
	% & \sum_{j=1}^{m} c_{kp} \cdot x_{jp} \ge 1 \qquad \forall k \in \{1, \ldots, t\}, p \in \{1, \ldots, q\} \\
	% & \sum_{k=1}^{t} \sum_{p = 1}^{q}\ s_{k} \cdot c_{kp} \cdot x_{p} \le d \qquad \text{(tamaño $k$ que entran por disco $d$)}\\
	& \sum_{p = 1}^{q} c_{kp} \cdot x_{p} \ge f_{k} \\
	%& y_{k} \ge 0, \quad \forall k \in \{1, \ldots, t\} \\
	& x_{p} \ge 0, \quad \forall p \in \{1, \ldots, q\}
\end{alignat*}

% \newpage
\section{Parte 5}\label{quinta:parte}

\subsection{Descripción}

El objetivo de este ejercicio es resolver el problema de las
Secciones~\ref{primera:parte}~y~\ref{cuarta:parte} suponiendo que los tamaños
de los archivos pertenecen a un conjunto pequeño. Para ello, se genera una
familia de conjuntos $H$ que cubra todos los archivos y quepa en los discos, se
plantea un modelo de programación lineal relajado $P$ y se resuelve su dual
para asignar valores a los archivos. Usando estos valores como indicadores de
importancia, se selecciona un subconjunto de archivos. Si la solución es
mejorable, se actualiza $H$ y se repite el proceso, ajustando finalmente la
solución para que sea entera.


\subsection{Pseudocódigo de alto nivel}
\begin{lstlisting}
INICIO obtener_conjuntos(archivo, threshold = infinito)
    # Leer los datos del archivo de entrada
    capacidad_disco, nombres_archivos, tamanos_archivos <- LeerInput5(ruta_archivo)
    tiempo_inicio <- TiempoActual()
    
    // PASO 1: Generar los conjuntos iniciales
    conjunto_H <- GenerarSubconjuntos(capacidad_disco * 10^6, nombres_archivos, tamanos_archivos)
    SI conjunto_H ES NULL ENTONCES
        RETORNAR NULL
    FIN SI
    
    MIENTRAS HAYA TIEMPO HACER
        // PASO 2 y 3: Resolver el modelo y obtener soluciones primal y dual
        modelo_P <- CrearModelo3(nombres_archivos, conjunto_H, threshold - (TiempoActual() - tiempo_inicio))
        x <- ObtenerSolucionPrimal3(modelo_P)
        SI x ES NULL ENTONCES
            TERMINAR CICLO
        FIN SI
        y <- ObtenerSolucionDual3(modelo_P)
        
        // PASO 4: Distribuir archivos y generar solucion
        solucion_modelo_2 <- ObtenerSolucion2(DistribuirArchivos2(capacidad_disco, nombres_archivos, tamanos_archivos, y, threshold - (TiempoActual() - tiempo_inicio)))
        SI solucion_modelo_2 ES NULL O NO HAY TIEMPO ENTONCES
            TERMINAR CICLO
        FIN SI

        // PASO 5: Verificar y actualizar conjuntos
        SI EsMejorSolucion(solucion_modelo_2) ENTONCES
            AgregarNuevoSubconjunto(conjunto_H, solucion_modelo_2)
        SINO
            TERMINAR CICLO
        FIN SI
    FIN MIENTRAS
    
    # PASO 6: Arreglar la solucion del paso 3 para que sea una solucion entera para nuestro problema.
    modelo_3_binario <- CrearModeloBinario(nombres_archivos, conjunto_H)
    x <- ObtenerSolucionPrimal3(modelo_3_binario)
    
    SI SeEncontroSolucion() O SeAgotoTiempo() ENTONCES
        RETORNAR [ObtenerConjuntosSeleccionados(x), modelo_3_binario, conjunto_H, nombres_archivos, tamanos_archivos, TiempoActual() - tiempo_inicio]
    FIN SI
    
    RETORNAR NULL
FIN
\end{lstlisting}

\subsection{Modelo $P$}
Este modelo es una relajación del modelo planteado en la Parte 3, considerando a $x_{j}$ como una variable continua.

\subsubsection{Definición de variables}

\noindent $n$: Constante, cantidad de archivos. \\

\noindent $m$: Constante, cantidad de conjuntos $H$. \\

\noindent $a_{ij}$: Constante binaria, donde $a_{ij} = 1$ indica que el conjunto $H_{j}$ contiene el archivo $i$, con $y_{ij} \in \{0, 1\}$, $\forall i \in \{1, \ldots, n\}$, $\forall j \in \{1, \ldots, m\}$. \\

\noindent $x_{j}$: Variable continua, donde $x_{j} = 1$ indica que el conjunto $H_{j}$ pertenece a $I$, con $x_{j} \in [0, 1]$, $\forall j \in \{1, \ldots, m\}$. \\


\subsubsection{Modelo}

\begin{alignat*}{2}
    \minimize & \sum_{j = 1}^{m} x_{j}\\
    \subjto   & \sum_{j=1}^{m} a_{i,j} \cdot x_j \geq 1 \quad \forall i,\ \text{(todos los archivos deben estar en al menos un conjunto elegido)}\\
              & x_{j} \in \{0,1\}, \quad \forall j \in \{1, \ldots, m\} \\
\end{alignat*}

\subsection{Dual de $P$}

Obtenemos el dual de $P$ considerando las restricciones de $P$.

\subsubsection{Definición de variables}

\noindent $n$: Constante, cantidad de archivos. \\

\noindent $m$: Constante, cantidad de conjuntos $H$. \\

\noindent $a_{ij}$: Constante binaria, donde $a_{ij} = 1$ indica que el conjunto $H_{j}$ contiene el archivo $i$, con $a_{ij} \in \{0, 1\}$, $\forall i \in \{1, \ldots, n\}$, $\forall j \in \{1, \ldots, m\}$. \\

\noindent $y_{i}$:  Variable dual continua asociada a la restricción de que el archivo $i$ debe estar cubierto.
        %Es decir, y_{i} se relaciona con sum_{j=1}^m a_{i, j} * x_{j} >= 1

\subsubsection{Modelo}

\begin{alignat*}{2}
    \maximize & \sum_{i = 1}^{n} y_{i}\\
    \subjto   & \sum_{i=1}^{n} a_{i,j} \cdot y_{i} \leq 1 \quad \forall j\\
              & y_{i} \in \{0,1\}, \quad \forall i \in \{1, \ldots, n\} \\
\end{alignat*}

\newpage
\section{Parte 6}

\subsection{Descripción}

En esta sección, se explican mejoras al algoritmo de la
Sección~\ref{quinta:parte}. Para agilizar el algoritmo, investigamos en la
documentación de PySCIPOpt con el objetivo de identificar los parámetros y
configuraciones que nos permitan optimizar el tiempo de ejecución del
código.

PySCIPOpt, al estar basado en SCIP, brinda muchas opciones para
personalizar su comportamiento, como ajustes en las estrategias de
búsqueda, límites en la exploración del árbol y técnicas específicas
para encontrar soluciones factibles de manera más eficiente. Estas
configuraciones permiten adaptar el rendimiento del solver a las
características particulares del problema, maximizando su eficacia y
reduciendo el tiempo computacional necesario. En nuestro caso,
realizamos las siguientes mejoras al modelo:

\begin{verbatim}
# Reduce el tiempo empleado en la heurística
model.setHeuristics(SCIP_PARAMSETTING.FAST)

# Para resolver los problemas fáciles más rápidamente
model.setEmphasis(SCIP_PARAMEMPHASIS.EASYCIP)

# Máximo número de procesadores
model.setParam("parallel/maxnthreads", 16)
\end{verbatim}

También, analizamos el setting \verb|model.setParam("parallel/mode", 0)|,
con $0$ para \emph{opportunistic} ó $1$ para \emph{deterministic}.
Pero no apreciamos cambios significativos en la performance.

\section{Resultados de script}

En esta sección, listamos los resultados obtenidos.

\newpage

\begin{landscape}
\begin{table}[h]
    \centering
    \begin{tabular}{l r r r r r r r r r r r r r r}
        \toprule
        \textbf{Caso} & \textbf{Cant} & \multicolumn{3}{c}{\textbf{Mejor 1}} & \multicolumn{3}{c}{\textbf{Mejor 4}} & \multicolumn{3}{c}{\textbf{Mejor 5}} & \multicolumn{3}{c}{\textbf{Mejor 6}} & \textbf{Cota Dual} \\
        \cmidrule(lr){3-5} \cmidrule(lr){6-8} \cmidrule(lr){9-11} \cmidrule(lr){12-14}
        & & Valor & Var & Tiempo & Valor & Var & Tiempo & Valor & Var & Tiempo & Valor & Var* & Tiempo & \\
        \midrule
        $f(n_1)$ = f(17) & 17 & 9 & 306 & 0.0 & 9 & 212 & 0.0 & 9 & 22 & 3.19 & 9 & 0 & 0.01 & 9 \\
        f(32) & 32 & - & - & 420 & 17 & 2922 & 0.0 & 18 & 30 & 5.05 & 17 & 0 & 0.01 & 17 \\
        $f(n_4)$ = f(74) & 74 & - & - & 420 & 38 & 159654 & 150.0 & 35 & 77 & 19.14 & 38 & 0 & 0.02 & 38 \\
        f(512) & 512 & - & - & 420 & - & - & 420 & 279 & 51 & 22.03 & 279 & 0 & 0.17 & 279 \\
        $f(n_5)$ = f(1158) & 1158 & - & - & 420 & - & - & 420 & 595 & 0 & 159.04 & 595 & 0 & 0.89 & 595 \\
        f(2048) & 2048 & - & - & 420 & - & - & 420 & 1021 & 14 & 420.79 & 1021 & 0 & 2.72 & 1021 \\
        $f(n_6)$ = f(16384) & 16384 & - & - & 420 & - & - & 420 & - & - & 420 & 8162 & 0 & 385.86 & 8162 \\
        \bottomrule
    \end{tabular}
    \caption{Resultados del Script. }
    \footnotesize{ Nota: Los resultados de la columna \texttt{Var6} indican 0 variables debido a que el modelo es resuelto por el presolve.}\\
    \footnotesize{ Nota 2: Los archivos del \texttt{Caso f(16384)} fueron generados duplicando un total de 8 veces los archivos del caso \texttt{f(2048)}.}
    \label{tab:resultados}
\end{table}
\end{landscape}

\newpage
\section{Conclusiones}

Logramos familiarizarnos con el uso de SCIP, y con PySCIPOpt.
Pudimos apreciar el alto nivel de abstracción de la sintaxis de Zimpl, utilizado directamente SCIP. Si bien nos llevó más tiempo del pensado, disfrutamos mucho realizar este trabajo ya que nos ayudó a familiarizarnos con las herramientas de modelado, y pudimos relacionarlas y aplicar lo visto en la materia.


%\newpage
\begin{thebibliography}{99}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\bibitem{koch}
	%author:
	Koch, T.\
	%date:
	(2024)
	%title:
	\emph{Zimpl User Guide},
	%place and publisher:
	Berlin: ZIB.
	%pages:
	% pp.~43--64.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{thebibliography}

\end{document}